<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>RDR Map Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

  <style>
    :root{
      --bg:#070a12;
      --panel: rgba(16,18,26,.88);
      --stroke: rgba(255,255,255,.14);
      --text: rgba(255,255,255,.96);
      --muted: rgba(255,255,255,.72);
      --muted2: rgba(255,255,255,.55);
      --shadow: 0 18px 55px rgba(0,0,0,.55);
      --r: 16px;
      --r2: 12px;
      --ui: system-ui,-apple-system,Segoe UI,Roboto,Arial;
      --mono: ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      --good:#22c55e;
      --warn:#f59e0b;
      --bad:#ef4444;
      --accent:#7c3aed;
    }

    html, body, #map { height: 100%; margin: 0; background: var(--bg); }
    #map { cursor: crosshair; outline:none; }

    /* SUPER visible cursor halo */
    .mouse-halo{
      position: fixed;
      width: 22px; height: 22px;
      border-radius: 999px;
      border: 2px solid rgba(255,255,255,.95);
      box-shadow: 0 0 0 4px rgba(124,58,237,.25), 0 10px 20px rgba(0,0,0,.55);
      pointer-events: none;
      transform: translate(-50%,-50%);
      z-index: 20000;
      mix-blend-mode: screen;
      display: none;
    }
    .mouse-halo.on{ display:block; }

    /* Panels */
    .panel{
      position: fixed;
      z-index: 9999;
      background: var(--panel);
      border: 1px solid var(--stroke);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      color: var(--text);
      font: 13px var(--ui);
      overflow: hidden;
    }
    .ph{
      padding: 12px;
      border-bottom: 1px solid var(--stroke);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .ph b{ font-size: 14px; letter-spacing:.2px; }
    .ph small{ color: var(--muted2); font-weight: 800; }

    .pb{ padding: 12px; }

    label.small{
      font-size: 11px;
      color: var(--muted2);
      font-weight: 900;
      letter-spacing:.2px;
      text-transform: uppercase;
      display:block;
      margin-bottom: 6px;
    }

    select, input, button, textarea{
      width: 100%;
      box-sizing: border-box;
      padding: 10px 10px;
      border-radius: var(--r2);
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.06);
      color: var(--text);
      font: 800 13px var(--ui);
      outline: none;
    }
    input[type="color"]{ padding: 0; height: 42px; }
    textarea{
      height: 120px;
      font: 11px var(--mono);
      font-weight: 650;
      background: rgba(0,0,0,.35);
      resize: vertical;
    }
    button{ cursor:pointer; transition:120ms ease; }
    button:hover{ background: rgba(255,255,255,.10); }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .row{ display:flex; gap:8px; margin: 8px 0; }
    .grid2{ display:grid; grid-template-columns: 1fr 1fr; gap:8px; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      font-weight: 900;
      user-select:none;
      white-space:nowrap;
    }
    .divider{ height:1px; background: var(--stroke); margin: 10px 0; }

    /* Layout */
    #left { top: 10px; left: 10px; width: 380px; max-width: calc(100vw - 24px); }
    #right{ top: 10px; right: 10px; width: 410px; max-width: calc(100vw - 24px); }

    #hud{
      position: fixed;
      left: 10px;
      bottom: 10px;
      z-index: 12000;
      display:flex;
      gap:10px;
      align-items:center;
      padding: 10px;
      border-radius: 18px;
      border: 1px solid var(--stroke);
      background: var(--panel);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      max-width: calc(100vw - 24px);
    }
    #hud .chip{
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      font-weight: 900;
      color: rgba(255,255,255,.92);
      user-select:none;
      white-space:nowrap;
    }
    #hud button{ width:auto; padding: 10px 12px; }

    /* Emoji picker */
    .emoji-grid{
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      gap:6px;
      margin-top: 8px;
    }
    .emoji-btn{
      padding: 10px 0;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      font-size: 18px;
      line-height: 1;
    }
    .emoji-btn.active{
      outline: 2px solid rgba(124,58,237,.7);
      background: rgba(124,58,237,.18);
    }

    /* List */
    .list{
      max-height: 220px;
      overflow:auto;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      background: rgba(0,0,0,.22);
    }
    .item{
      padding: 10px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      gap:10px;
      align-items:flex-start;
      cursor:pointer;
    }
    .item:last-child{ border-bottom:0; }
    .item:hover{ background: rgba(255,255,255,.06); }
    .item .ic{
      width: 34px; height: 34px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      display:grid;
      place-items:center;
      font-size: 18px;
      flex-shrink:0;
    }
    .item b{ display:block; font-size: 13px; }
    .item small{ display:block; color: var(--muted2); font-weight: 800; margin-top: 2px; }

    /* Map object styling */
    .leaflet-control-zoom a{
      background: rgba(16,18,26,.92) !important;
      color:#fff !important;
      border: 1px solid rgba(255,255,255,.14) !important;
      width: 36px !important; height: 36px !important;
      line-height: 34px !important;
    }
    .leaflet-control-zoom { box-shadow: var(--shadow) !important; border-radius: 12px !important; overflow:hidden; }
    .leaflet-popup-content { margin: 12px 14px; }

    /* Marker */
    .m-badge{
      width: 34px; height: 34px;
      border-radius: 999px;
      display:grid;
      place-items:center;
      border: 2px solid rgba(255,255,255,.95);
      background: rgba(10,12,16,.72);
      box-shadow: 0 2px 16px rgba(0,0,0,.6);
      user-select:none;
      font: 900 14px/1 var(--ui);
      color: rgba(255,255,255,.95);
    }
    .m-emoji{
      width: 34px; height: 34px;
      border-radius: 14px;
      display:grid;
      place-items:center;
      border: 2px solid rgba(255,255,255,.92);
      background: rgba(10,12,16,.72);
      box-shadow: 0 2px 16px rgba(0,0,0,.6);
      user-select:none;
      font-size: 18px;
    }

    @media (max-width: 980px){
      #right { top:auto; bottom: 86px; right:10px; width: 410px; }
    }
    @media (max-width: 520px){
      #left, #right{ width: calc(100vw - 24px); }
      #right{ right:10px; left:10px; }
      .emoji-grid{ grid-template-columns: repeat(7, 1fr); }
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="mouse-halo" id="halo"></div>

  <!-- LEFT -->
  <aside class="panel" id="left">
    <div class="ph">
      <div>
        <b>RP Map</b><br>
        <small id="sub">Viewer ‚Ä¢ Click things to inspect</small>
      </div>
      <div class="pill" id="savePill">Saved</div>
    </div>
    <div class="pb">
      <label class="small">Search</label>
      <input id="q" placeholder="Search houses, POIs, roads, counties‚Ä¶" />

      <div class="row">
        <div style="flex:1">
          <label class="small">Mode</label>
          <select id="mode">
            <option value="inspect">Inspect (Viewer)</option>
            <option value="select" disabled>Select / Move (Editor)</option>
            <option value="marker" disabled>Place Marker (Editor)</option>
            <option value="road" disabled>Draw Road (Editor)</option>
            <option value="border" disabled>Draw Border (Editor)</option>
            <option value="area" disabled>Draw County/Area (Editor)</option>
            <option value="erase" disabled>Erase (Editor)</option>
          </select>
        </div>
        <div style="width:130px">
          <label class="small">Color</label>
          <input id="color" type="color" value="#ffffff" />
        </div>
      </div>

      <div class="row">
        <div style="flex:1">
          <label class="small">Marker Style</label>
          <select id="markerStyle">
            <option value="house">House #</option>
            <option value="emoji">Emoji</option>
          </select>
        </div>
        <div style="width:130px">
          <label class="small">House #</label>
          <input id="houseNum" type="number" min="1" placeholder="Auto" />
        </div>
      </div>

      <div id="emojiBlock" style="display:none;">
        <label class="small">Pick Emoji</label>
        <div class="emoji-grid" id="emojiGrid"></div>
        <div class="row">
          <input id="customEmoji" placeholder="Add emoji (paste here) e.g. üè¶" />
          <button id="addEmoji" style="width:140px">Add</button>
        </div>
      </div>

      <div class="grid2" style="margin-top:10px;">
        <button id="finish" disabled>Finish Shape</button>
        <button id="undo" disabled>Undo Point</button>
        <button id="del" disabled>Delete Selected</button>
        <button id="clearSel" disabled>Clear Select</button>
      </div>

      <div class="row">
        <button id="resetView">Reset View</button>
        <button id="export">Export</button>
      </div>
      <div class="row">
        <button id="import">Import</button>
        <button id="clearAll" disabled>Clear All</button>
      </div>

      <div class="divider"></div>

      <label class="small">Export / Import JSON</label>
      <textarea id="box" placeholder="Export JSON here or paste JSON to import‚Ä¶"></textarea>

      <div class="divider"></div>

      <label class="small">Quick List</label>
      <div class="list" id="list"></div>

      <div class="divider"></div>
      <div style="color:var(--muted); font-size:12px; line-height:1.35">
        Controls:
        <br>‚Ä¢ <b>Wheel</b> zoom ‚Ä¢ <b>Drag</b> pan
        <br>‚Ä¢ <b>+</b>/<b>-</b> zoom ‚Ä¢ <b>0</b> reset
        <br>‚Ä¢ <b>ESC</b> cancel drawing
      </div>
    </div>
  </aside>

  <!-- RIGHT -->
  <aside class="panel" id="right">
    <div class="ph">
      <div>
        <b>Info</b><br>
        <small id="infoSub">Click a marker/road/border/county</small>
      </div>
      <button id="closeInfo" style="width:auto; padding:8px 10px;">Clear</button>
    </div>
    <div class="pb" id="info">
      <div style="color:var(--muted); font-size:12px;">Nothing selected yet.</div>
    </div>
  </aside>

  <!-- HUD -->
  <div id="hud">
    <span class="chip" id="chipXY">x: ‚Äî y: ‚Äî</span>
    <span class="chip" id="chipZoom">zoom: ‚Äî</span>
    <span class="chip" id="chipMode">mode: inspect</span>
    <button id="zOut">‚àí</button>
    <button id="zIn">+</button>
    <button id="signIn">Sign in</button>
    <button id="signOut" disabled>Sign out</button>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <script>
    // =========================
    // CONFIG
    // =========================
    const MAP_IMAGE_URL = "./assets/rdo-map.jpeg";

    // Update these if your map image has a different size:
    const MAP_W = 1536;
    const MAP_H = 1152;

    // SAVE SETTINGS
    const STORAGE_KEY = "rdr_map_editor_v3";

    // OPTIONAL VERCEL API (only works on Vercel deploy, not GitHub Pages)
    const USE_VERCEL_API = false; // set true when you're on Vercel and have /api/load & /api/save
    const MAP_ID = "rdo_main";
    let editorCode = ""; // will send as header "x-editor-code" if you enable it server-side

    // =========================
    // DATA MODEL
    // =========================
    // markers: {id, kind:'house'|'emoji', x,y, color, houseNumber?, emoji?, name, meta:{description,notes,links}}
    // lines:   {id, kind:'road'|'border', color, name, pts:[[y,x]...], meta:{}}
    // areas:   {id, kind:'county'|'area', color, name, pts:[[y,x]...], meta:{}}
    let data = {
      meta: { mapId: MAP_ID, updatedAt: null },
      markers: [],
      lines: [],
      areas: []
    };

    // =========================
    // MAP
    // =========================
    const map = L.map("map", {
      crs: L.CRS.Simple,
      minZoom: -3,
      maxZoom: 4,
      zoomSnap: 0.25,
      zoomDelta: 0.25,
      wheelPxPerZoomLevel: 90,
      inertia: true,
      inertiaDeceleration: 2400,
      zoomControl: true
    });

    const bounds = [[0,0],[MAP_H, MAP_W]];
    L.imageOverlay(MAP_IMAGE_URL, bounds).addTo(map);
    map.fitBounds(bounds);
    map.setMaxBounds(L.latLngBounds(bounds).pad(0.25));

    const layerMarkers = L.layerGroup().addTo(map);
    const layerRoads   = L.layerGroup().addTo(map);
    const layerBorders = L.layerGroup().addTo(map);
    const layerAreas   = L.layerGroup().addTo(map);

    // Cursor halo
    const halo = document.getElementById("halo");
    const mapEl = document.getElementById("map");
    mapEl.addEventListener("mouseenter", ()=>halo.classList.add("on"));
    mapEl.addEventListener("mouseleave", ()=>halo.classList.remove("on"));
    mapEl.addEventListener("mousemove", (e)=>{
      halo.style.left = e.clientX + "px";
      halo.style.top  = e.clientY + "px";
    });

    // =========================
    // UI
    // =========================
    const savePill = document.getElementById("savePill");
    const sub = document.getElementById("sub");
    const modeSel = document.getElementById("mode");
    const colorInp = document.getElementById("color");
    const qInp = document.getElementById("q");
    const box = document.getElementById("box");
    const listEl = document.getElementById("list");

    const markerStyleSel = document.getElementById("markerStyle");
    const houseNumInp = document.getElementById("houseNum");
    const emojiBlock = document.getElementById("emojiBlock");
    const emojiGrid = document.getElementById("emojiGrid");
    const customEmoji = document.getElementById("customEmoji");
    const addEmojiBtn = document.getElementById("addEmoji");

    const finishBtn = document.getElementById("finish");
    const undoBtn = document.getElementById("undo");
    const delBtn = document.getElementById("del");
    const clearSelBtn = document.getElementById("clearSel");
    const clearAllBtn = document.getElementById("clearAll");

    const resetViewBtn = document.getElementById("resetView");
    const exportBtn = document.getElementById("export");
    const importBtn = document.getElementById("import");

    const info = document.getElementById("info");
    const infoSub = document.getElementById("infoSub");
    const closeInfoBtn = document.getElementById("closeInfo");

    const chipXY = document.getElementById("chipXY");
    const chipZoom = document.getElementById("chipZoom");
    const chipMode = document.getElementById("chipMode");
    const zIn = document.getElementById("zIn");
    const zOut = document.getElementById("zOut");
    const signInBtn = document.getElementById("signIn");
    const signOutBtn = document.getElementById("signOut");

    // =========================
    // EMOJI SET (clickable)
    // Add more here anytime.
    // =========================
    let EMOJIS = [
      "üìç","üè†","üè¶","üè™","üçª","üçΩÔ∏è","üß±","‚õ™","üè•","üöî","‚≠ê","üß®","üí∞","üß™","üõí","üêé",
      "‚õ∫","ü™ì","üå≤","‚õ∞Ô∏è","üåä","üêä","üêª","üê∫","ü¶å","üéØ","üì¶","üó∫Ô∏è","‚öíÔ∏è","üß∑","ü™ô","üîí"
    ];
    let selectedEmoji = "üìç";

    function renderEmojiPicker(){
      emojiGrid.innerHTML = "";
      EMOJIS.forEach(e=>{
        const b = document.createElement("button");
        b.className = "emoji-btn" + (e === selectedEmoji ? " active" : "");
        b.type = "button";
        b.textContent = e;
        b.onclick = ()=>{
          selectedEmoji = e;
          renderEmojiPicker();
        };
        emojiGrid.appendChild(b);
      });
    }
    renderEmojiPicker();

    addEmojiBtn.onclick = ()=>{
      const e = (customEmoji.value || "").trim();
      if (!e) return;
      // Keep it simple: only accept 1-3 chars (emoji can be multi-codepoint, but this is fine)
      if (e.length > 6) return alert("That looks too long. Paste a single emoji.");
      if (!EMOJIS.includes(e)) EMOJIS.unshift(e);
      selectedEmoji = e;
      customEmoji.value = "";
      renderEmojiPicker();
      scheduleSave();
    };

    markerStyleSel.addEventListener("change", ()=>{
      const v = markerStyleSel.value;
      emojiBlock.style.display = (v === "emoji") ? "block" : "none";
    });

    // =========================
    // AUTH (front-end lock)
    // =========================
    let isEditor = false;

    function setEditorMode(on){
      isEditor = on;

      // enable/disable editor modes
      const editorModes = new Set(["select","marker","road","border","area","erase"]);
      for (const opt of modeSel.options){
        opt.disabled = editorModes.has(opt.value) ? !isEditor : false;
      }
      if (!isEditor) modeSel.value = "inspect";

      finishBtn.disabled = !isEditor;
      undoBtn.disabled = !isEditor;
      delBtn.disabled = !isEditor;
      clearSelBtn.disabled = !isEditor;
      clearAllBtn.disabled = !isEditor;

      signInBtn.disabled = isEditor;
      signOutBtn.disabled = !isEditor;

      sub.textContent = isEditor
        ? "Editor ‚Ä¢ Place emoji markers, draw roads/borders/counties"
        : "Viewer ‚Ä¢ Click things to inspect";

      chipMode.textContent = `mode: ${modeSel.value}`;
      render();
    }

    signInBtn.onclick = ()=>{
      const code = prompt("Editor passcode:");
      if (!code) return;
      // you can enforce a client check if you want:
      // if (code !== "1234") return alert("Wrong code");
      editorCode = code; // used for Vercel API header if enabled
      setEditorMode(true);
    };
    signOutBtn.onclick = ()=>{
      editorCode = "";
      setEditorMode(false);
    };

    // =========================
    // SAVING
    // =========================
    function setSaved(ok){
      savePill.textContent = ok ? "Saved" : "Saving‚Ä¶";
      savePill.style.opacity = ok ? "0.9" : "1";
    }

    function saveLocal(){
      try{
        data.meta.updatedAt = new Date().toISOString();
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      }catch{}
    }

    async function saveServer(){
      if (!USE_VERCEL_API) return true;
      try{
        const r = await fetch("/api/save", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            ...(editorCode ? { "x-editor-code": editorCode } : {})
          },
          body: JSON.stringify({ mapId: MAP_ID, payload: data, message: `Auto-save ${MAP_ID}` })
        });
        const j = await r.json().catch(()=>null);
        if (!r.ok) throw new Error(j?.error || "Save failed");
        return true;
      }catch(e){
        console.warn("Server save failed:", e);
        return false;
      }
    }

    let saveTimer = null;
    function scheduleSave(){
      setSaved(false);
      if (saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(async ()=>{
        saveLocal();
        await saveServer();
        setSaved(true);
        rebuildList();
      }, 550);
    }

    async function loadServer(){
      const r = await fetch(`/api/load?mapId=${encodeURIComponent(MAP_ID)}`);
      const j = await r.json();
      if (j?.ok && j?.payload) return j.payload;
      return null;
    }

    async function bootLoad(){
      // Try server if enabled
      if (USE_VERCEL_API){
        const s = await loadServer();
        if (s && typeof s === "object") {
          data = s;
          setSaved(true);
          render();
          rebuildList();
          return;
        }
      }
      // Fallback: local
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (raw){
          const parsed = JSON.parse(raw);
          if (parsed && Array.isArray(parsed.markers) && Array.isArray(parsed.lines) && Array.isArray(parsed.areas)) {
            data = parsed;
          }
        }
      }catch{}
      setSaved(true);
      render();
      rebuildList();
    }

    // =========================
    // HELPERS
    // =========================
    function esc(s){
      return String(s ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }
    function newId(prefix){
      return `${prefix}-${Math.random().toString(16).slice(2,8)}-${Date.now().toString(16).slice(-4)}`;
    }
    function nextHouse(){
      const nums = data.markers.filter(m=>m.kind==="house").map(m=>m.houseNumber||0);
      let n=1; while(nums.includes(n)) n++;
      return n;
    }

    function markerIcon(m){
      const color = m.color || "#ffffff";
      if (m.kind === "house"){
        const num = m.houseNumber ?? 1;
        return L.divIcon({
          className:"",
          html:`<div class="m-badge" style="border-color:${color}">${esc(num)}</div>`,
          iconSize:[34,34],
          iconAnchor:[17,17]
        });
      }
      const emoji = m.emoji || "üìç";
      return L.divIcon({
        className:"",
        html:`<div class="m-emoji" style="border-color:${color}">${esc(emoji)}</div>`,
        iconSize:[34,34],
        iconAnchor:[17,17]
      });
    }

    // =========================
    // RENDER + SELECTION
    // =========================
    let selected = null; // {type:'marker'|'line'|'area', id, obj, layer}
    let drawPts = [];
    let drawPreview = null;

    function clearSelection(){
      selected = null;
      infoSub.textContent = "Click a marker/road/border/county";
      info.innerHTML = `<div style="color:var(--muted); font-size:12px;">Nothing selected yet.</div>`;
    }

    function openInfoFor(sel){
      const o = sel.obj;
      const meta = (o.meta && typeof o.meta === "object") ? o.meta : (o.meta = {});
      const title = o.name || "(unnamed)";
      const kind =
        sel.type === "marker" ? (o.kind === "house" ? "HOUSE" : "MARKER") :
        sel.type === "line" ? (o.kind === "border" ? "BORDER" : "ROAD") :
        "COUNTY/AREA";

      infoSub.textContent = `${kind} ‚Ä¢ ${o.id}`;

      info.innerHTML = `
        <label class="small">Name</label>
        <input id="f_name" value="${esc(o.name || "")}" placeholder="Name‚Ä¶" />

        <div class="row">
          <div style="flex:1">
            <label class="small">Color</label>
            <input id="f_color" type="color" value="${esc(o.color || "#ffffff")}" />
          </div>
          <div style="width:160px">
            <label class="small">Type</label>
            <input value="${esc(kind)}" disabled />
          </div>
        </div>

        ${sel.type === "marker" && o.kind === "house" ? `
          <label class="small">House #</label>
          <input id="f_house" type="number" min="1" value="${esc(o.houseNumber ?? "")}" />
        ` : ""}

        ${sel.type === "marker" && o.kind !== "house" ? `
          <label class="small">Emoji</label>
          <input id="f_emoji" value="${esc(o.emoji || "üìç")}" placeholder="Emoji (paste) e.g. üè¶" />
        ` : ""}

        <label class="small">Description</label>
        <textarea id="f_desc" placeholder="What is this?">${esc(meta.description || "")}</textarea>

        <label class="small">Notes / Rules</label>
        <textarea id="f_notes" placeholder="Rules, details, lore, etc.">${esc(meta.notes || "")}</textarea>

        <div class="row">
          <button id="saveInfo">Save Info</button>
          <button id="focus">Focus</button>
        </div>

        <div style="color:var(--muted2); font-size:12px; margin-top:6px;">
          ${sel.type === "marker"
            ? `coords: x:${esc(o.x)} y:${esc(o.y)}`
            : `points: ${esc(o.pts?.length || 0)}`
          }
        </div>
      `;

      document.getElementById("saveInfo").onclick = ()=>{
        o.name = (document.getElementById("f_name").value || "").trim();
        o.color = (document.getElementById("f_color").value || "#ffffff").trim();

        if (sel.type === "marker" && o.kind === "house"){
          const n = parseInt(document.getElementById("f_house").value, 10);
          if (Number.isFinite(n) && n > 0) o.houseNumber = n;
        }
        if (sel.type === "marker" && o.kind !== "house"){
          const e = (document.getElementById("f_emoji").value || "").trim();
          if (e) o.emoji = e;
        }
        meta.description = (document.getElementById("f_desc").value || "").trim();
        meta.notes = (document.getElementById("f_notes").value || "").trim();

        scheduleSave();
        render();
        rebuildList();
        openInfoFor(sel); // refresh UI with new values
      };

      document.getElementById("focus").onclick = ()=>{
        if (sel.type === "marker"){
          map.setView([o.y, o.x], Math.max(map.getZoom(), 1.0), { animate:true });
        } else {
          const b = L.latLngBounds(o.pts || []);
          if (b.isValid()) map.fitBounds(b.pad(0.2), { animate:true });
        }
      };
    }

    function render(){
      layerMarkers.clearLayers();
      layerRoads.clearLayers();
      layerBorders.clearLayers();
      layerAreas.clearLayers();

      // Areas (counties)
      for (const a of data.areas){
        const poly = L.polygon(a.pts || [], {
          color: a.color || "#ffffff",
          weight: 3,
          opacity: 0.95,
          fillOpacity: 0.12
        }).addTo(layerAreas);

        poly.on("click", (e)=>{
          L.DomEvent.stopPropagation(e);
          selected = { type:"area", id:a.id, obj:a, layer: poly };
          openInfoFor(selected);
          if (modeSel.value === "erase" && isEditor) deleteSelected();
        });
      }

      // Lines (roads + borders)
      for (const ln of data.lines){
        const isBorder = ln.kind === "border";
        const line = L.polyline(ln.pts || [], {
          color: ln.color || "#ffffff",
          weight: isBorder ? 6 : 4,
          opacity: 0.95,
          dashArray: isBorder ? "10 6" : null
        }).addTo(isBorder ? layerBorders : layerRoads);

        line.on("click", (e)=>{
          L.DomEvent.stopPropagation(e);
          selected = { type:"line", id:ln.id, obj:ln, layer: line };
          openInfoFor(selected);
          if (modeSel.value === "erase" && isEditor) deleteSelected();
        });
      }

      // Markers
      for (const m of data.markers){
        const mk = L.marker([m.y, m.x], {
          icon: markerIcon(m),
          draggable: isEditor && modeSel.value === "select"
        }).addTo(layerMarkers);

        mk.on("click", (e)=>{
          L.DomEvent.stopPropagation(e);
          selected = { type:"marker", id:m.id, obj:m, layer: mk };
          openInfoFor(selected);
          if (modeSel.value === "erase" && isEditor) deleteSelected();
        });

        mk.on("dragend", ()=>{
          if (!isEditor) return;
          const p = mk.getLatLng();
          m.y = Math.round(p.lat);
          m.x = Math.round(p.lng);
          scheduleSave();
          openInfoFor({ type:"marker", id:m.id, obj:m, layer: mk });
        });
      }

      chipMode.textContent = `mode: ${modeSel.value}`;
      chipZoom.textContent = `zoom: ${map.getZoom().toFixed(2)}`;
    }

    function deleteSelected(){
      if (!selected) return;
      if (selected.type === "marker") data.markers = data.markers.filter(x=>x.id !== selected.id);
      if (selected.type === "line")   data.lines   = data.lines.filter(x=>x.id !== selected.id);
      if (selected.type === "area")   data.areas   = data.areas.filter(x=>x.id !== selected.id);
      clearSelection();
      scheduleSave();
      render();
      rebuildList();
    }

    // =========================
    // DRAWING
    // =========================
    function clearDraw(){
      drawPts = [];
      if (drawPreview) { map.removeLayer(drawPreview); drawPreview = null; }
    }

    function drawPreviewNow(){
      if (drawPreview) map.removeLayer(drawPreview);
      const mode = modeSel.value;
      const col = colorInp.value || "#ffffff";

      if (mode === "road" || mode === "border"){
        drawPreview = L.polyline(drawPts, {
          color: col,
          weight: mode === "border" ? 6 : 4,
          opacity: 0.95,
          dashArray: mode === "border" ? "10 6" : null
        }).addTo(map);
      } else if (mode === "area"){
        drawPreview = L.polygon(drawPts, {
          color: col,
          weight: 3,
          opacity: 0.95,
          fillOpacity: 0.10
        }).addTo(map);
      }
    }

    map.on("click", (e)=>{
      const mode = modeSel.value;
      const x = Math.round(e.latlng.lng);
      const y = Math.round(e.latlng.lat);

      if (mode === "inspect") { clearSelection(); return; }
      if (!isEditor) return;

      if (mode === "marker"){
        const style = markerStyleSel.value;
        const color = colorInp.value || "#ffffff";

        if (style === "house"){
          const forced = parseInt(houseNumInp.value, 10);
          const n = Number.isFinite(forced) && forced > 0 ? forced : nextHouse();
          const obj = {
            id: newId("house"),
            kind: "house",
            houseNumber: n,
            name: `House #${n}`,
            x, y,
            color,
            meta: { description:"", notes:"" }
          };
          data.markers.push(obj);
          scheduleSave();
          render();
          selected = { type:"marker", id: obj.id, obj, layer:null };
          openInfoFor(selected);
          return;
        }

        // emoji marker
        const obj = {
          id: newId("m"),
          kind: "emoji",
          emoji: selectedEmoji || "üìç",
          name: "POI",
          x, y,
          color,
          meta: { description:"", notes:"" }
        };
        data.markers.push(obj);
        scheduleSave();
        render();
        selected = { type:"marker", id: obj.id, obj, layer:null };
        openInfoFor(selected);
        return;
      }

      if (mode === "road" || mode === "border" || mode === "area"){
        drawPts.push([y, x]);
        drawPreviewNow();
        setSaved(false);
        return;
      }

      if (mode === "erase"){
        // clicking empty space clears selection
        clearSelection();
      }
    });

    finishBtn.onclick = ()=>{
      if (!isEditor) return;
      const mode = modeSel.value;
      const col = colorInp.value || "#ffffff";

      if ((mode === "road" || mode === "border") && drawPts.length >= 2){
        const name = prompt(mode === "border" ? "Border name:" : "Road name:", "") || "";
        const obj = {
          id: newId(mode),
          kind: mode,
          name: name.trim() || (mode === "border" ? "Border" : "Road"),
          color: col,
          pts: drawPts.slice(),
          meta: { description:"", notes:"" }
        };
        data.lines.push(obj);
        clearDraw();
        scheduleSave();
        render();
        selected = { type:"line", id: obj.id, obj, layer:null };
        openInfoFor(selected);
        return;
      }

      if (mode === "area" && drawPts.length >= 3){
        const name = prompt("County/Area name:", "") || "";
        const obj = {
          id: newId("county"),
          kind: "county",
          name: name.trim() || "County",
          color: col,
          pts: drawPts.slice(),
          meta: { description:"", notes:"" }
        };
        data.areas.push(obj);
        clearDraw();
        scheduleSave();
        render();
        selected = { type:"area", id: obj.id, obj, layer:null };
        openInfoFor(selected);
        return;
      }

      alert("Not enough points to finish.");
    };

    undoBtn.onclick = ()=>{
      if (!isEditor) return;
      if (!drawPts.length) return;
      drawPts.pop();
      drawPreviewNow();
      setSaved(false);
    };

    // Keyboard helpers
    window.addEventListener("keydown", (e)=>{
      if (e.key === "Escape"){ clearDraw(); render(); }
      if (e.key === "+" || e.key === "=") map.zoomIn(0.5);
      if (e.key === "-" || e.key === "_") map.zoomOut(0.5);
      if (e.key === "0") map.fitBounds(bounds);
    });

    // =========================
    // LIST + SEARCH
    // =========================
    function scoreHit(s, q){
      s = (s||"").toLowerCase();
      q = (q||"").toLowerCase();
      if (!q) return 0;
      if (s === q) return 3;
      if (s.startsWith(q)) return 2;
      if (s.includes(q)) return 1;
      return 0;
    }

    function rebuildList(){
      const q = (qInp.value || "").trim().toLowerCase();
      const rows = [];

      for (const m of data.markers){
        const label = m.kind === "house" ? `House #${m.houseNumber ?? ""}` : (m.emoji || "üìç");
        const name = m.name || (m.kind === "house" ? `House #${m.houseNumber ?? ""}` : "Marker");
        const hit = Math.max(scoreHit(name,q), scoreHit(label,q), scoreHit(m.meta?.notes,q), scoreHit(m.meta?.description,q));
        if (!q || hit) rows.push({ type:"marker", obj:m, hit, icon: (m.kind==="house" ? "üè†" : (m.emoji || "üìç")), title:name, sub:`x:${m.x} y:${m.y}` });
      }

      for (const ln of data.lines){
        const icon = ln.kind === "border" ? "üß±" : "üõ£Ô∏è";
        const name = ln.name || (ln.kind === "border" ? "Border" : "Road");
        const hit = Math.max(scoreHit(name,q), scoreHit(ln.meta?.notes,q), scoreHit(ln.meta?.description,q));
        if (!q || hit) rows.push({ type:"line", obj:ln, hit, icon, title:name, sub:`pts:${ln.pts?.length || 0}` });
      }

      for (const a of data.areas){
        const icon = "üó∫Ô∏è";
        const name = a.name || "County";
        const hit = Math.max(scoreHit(name,q), scoreHit(a.meta?.notes,q), scoreHit(a.meta?.description,q));
        if (!q || hit) rows.push({ type:"area", obj:a, hit, icon, title:name, sub:`pts:${a.pts?.length || 0}` });
      }

      rows.sort((A,B)=> (B.hit - A.hit) || A.title.localeCompare(B.title));
      listEl.innerHTML = rows.length ? "" : `<div class="item"><div><b>No matches</b><small>Try a different search</small></div></div>`;

      rows.slice(0, 80).forEach(r=>{
        const div = document.createElement("div");
        div.className = "item";
        div.innerHTML = `
          <div class="ic">${esc(r.icon)}</div>
          <div style="min-width:0">
            <b>${esc(r.title)}</b>
            <small>${esc(r.sub)}</small>
          </div>
        `;
        div.onclick = ()=>{
          // focus + open info
          if (r.type === "marker"){
            map.setView([r.obj.y, r.obj.x], Math.max(map.getZoom(), 1.25), { animate:true });
            selected = { type:"marker", id:r.obj.id, obj:r.obj, layer:null };
            openInfoFor(selected);
          } else if (r.type === "line"){
            const b = L.latLngBounds(r.obj.pts || []);
            if (b.isValid()) map.fitBounds(b.pad(0.2), { animate:true });
            selected = { type:"line", id:r.obj.id, obj:r.obj, layer:null };
            openInfoFor(selected);
          } else {
            const b = L.latLngBounds(r.obj.pts || []);
            if (b.isValid()) map.fitBounds(b.pad(0.2), { animate:true });
            selected = { type:"area", id:r.obj.id, obj:r.obj, layer:null };
            openInfoFor(selected);
          }
        };
        listEl.appendChild(div);
      });
    }

    qInp.addEventListener("input", rebuildList);

    // =========================
    // BUTTONS
    // =========================
    closeInfoBtn.onclick = clearSelection;

    delBtn.onclick = ()=>{ if (isEditor) deleteSelected(); };
    clearSelBtn.onclick = clearSelection;

    clearAllBtn.onclick = ()=>{
      if (!isEditor) return;
      if (!confirm("Clear EVERYTHING?")) return;
      data.markers = [];
      data.lines = [];
      data.areas = [];
      clearSelection();
      clearDraw();
      scheduleSave();
      render();
      rebuildList();
    };

    resetViewBtn.onclick = ()=> map.fitBounds(bounds, { animate:true });

    exportBtn.onclick = ()=> box.value = JSON.stringify(data, null, 2);

    importBtn.onclick = ()=>{
      try{
        const parsed = JSON.parse(box.value);
        if (!parsed || typeof parsed !== "object") throw new Error("Invalid JSON");
        if (!Array.isArray(parsed.markers) || !Array.isArray(parsed.lines) || !Array.isArray(parsed.areas)) {
          throw new Error("JSON must have {markers:[], lines:[], areas:[]}");
        }
        data = parsed;
        clearSelection();
        clearDraw();
        scheduleSave();
        render();
        rebuildList();
        alert("Imported!");
      }catch(e){
        alert("Import failed: " + (e?.message || e));
      }
    };

    modeSel.addEventListener("change", ()=>{
      clearDraw();
      chipMode.textContent = `mode: ${modeSel.value}`;
      render();
    });

    // HUD zoom
    zIn.onclick  = ()=> map.zoomIn(0.5);
    zOut.onclick = ()=> map.zoomOut(0.5);

    map.on("mousemove", (e)=>{
      const x = Math.round(e.latlng.lng);
      const y = Math.round(e.latlng.lat);
      chipXY.textContent = `x:${x} y:${y}`;
    });
    map.on("zoomend", ()=> chipZoom.textContent = `zoom: ${map.getZoom().toFixed(2)}`);
    chipZoom.textContent = `zoom: ${map.getZoom().toFixed(2)}`;

    // =========================
    // BOOT
    // =========================
    // Seed some demo stuff once if empty
    function seedIfEmpty(){
      if (data.markers.length || data.lines.length || data.areas.length) return;
      data.markers.push(
        { id:"house-1", kind:"house", houseNumber:1, name:"House #1", x: 820, y: 610, color:"#ffffff", meta:{ description:"Starter house", notes:"Edit me on the right panel." } },
        { id:"bank", kind:"emoji", emoji:"üè¶", name:"Bank", x: 1180, y: 700, color:"#22c55e", meta:{ description:"Bank POI", notes:"Loans, storage, etc." } },
        { id:"sheriff", kind:"emoji", emoji:"‚≠ê", name:"Sheriff Office", x: 1210, y: 740, color:"#f59e0b", meta:{ description:"Law zone", notes:"No shooting inside." } }
      );
      data.lines.push(
        { id:"road-1", kind:"road", name:"Main Road", color:"#f59e0b", pts:[[520,820],[620,880],[720,910]], meta:{ description:"Road", notes:"" } },
        { id:"border-1", kind:"border", name:"County Border", color:"#ffffff", pts:[[460,680],[560,760],[640,740],[700,680]], meta:{ description:"Border", notes:"" } }
      );
      data.areas.push(
        { id:"county-1", kind:"county", name:"Example County", color:"#3b82f6", pts:[[380,620],[360,740],[450,820],[520,700]], meta:{ description:"County", notes:"Rules go here." } }
      );
      saveLocal();
    }

    bootLoad().then(()=>{
      seedIfEmpty();
      setSaved(true);
      setEditorMode(false);
      markerStyleSel.dispatchEvent(new Event("change"));
      render();
      rebuildList();
    });
  </script>
</body>
</html>
